import { MdxImage as Image } from '@/components/MdxImage';
import { getMetadataBySlug } from '../articleList';
import { ManagerCard } from './ManagerCard';
import inFlyoutImage from './in-flyout.png';
import inMainPageImage from './in-main-page.png';

export const metadata = getMetadataBySlug('container-queries');

<article>
# Container Queries

As the web has evolved, we have moved to using more and more components. Be it
Frontend frameworks like React or Svelte, or templating languages like laravel Blade; all of them
depend on the concept of components. These components can be used inside dialogs, split-screens or
the main content area, meaning their size requirements can vary widely. Luckily for us, CSS has
caught up with this trend and has introduced a new feature called Container Queries, which allows
us to style components based on their container size.

You may be wondering, “Hasan we already have media queries!”. And you are right of course, but
media queries are based on the viewport size, and with how you can have your component anywhere
wouldn't it be nice if your component could be aware of its container size and adjust accordingly?
And all that without a single line of JS? Now that I have your attention (hopefully), let's dive in.

## When to use Container Queries

Below I am rendering a simple ManagerCard component that we use in bunch of places in [Sematext](https://sematext.com/).
This is a simplified (and cruder) version of the original component.

<ManagerCard />
<figcaption>
  With MDX I can render the component instead of using an image.
</figcaption>

The component can be rendered in different places on our site as shown below:

<figure>
  <Image src={inMainPageImage} alt="ManagerCard in main page" />
  <figcaption>ManagerCard in main page</figcaption>
</figure>
<figure>
  <Image src={inFlyoutImage} alt="ManagerCard in flyout" />
  <figcaption>ManagerCard in flyout</figcaption>
</figure>

Before I introduced container queries, we had to pass additional props like “minimal” to the
component to adjust its sizing depending on where it was rendered. And this could become overly
complex as we we continue to add it in different places. This becomes worse when you consider smaller
screens like tablets.

But with container queries it did not matter where this component is used. It will automatically adjust
its styling based on space available. This allows use to get rid of the additional props and makes the
component more reusable and easier to maintain.

## How to use Container Queries

Lets see how would use container queries to style the ManagerCard component.

```js
<div className="manager-card-container">
  <div className="manager-card">
    <h3>ManagerCard</h3>
    <p>Some content</p>
  </div>
</div>
```

To begin with we need to define a container and set the container-type property:

```css
.manager-card-container {
  container-type: inline-size;
  width: 100%;
}
```

The container-type property can have 3 possible values:

- size: Uses width and height of the container
- inline-size: Uses width of the container
- normal: The element is not a query container

We will explain in a little more detail the what these values mean but first lets see
how we use they query part of container queries.

```css
// default size
.manager-card {
  display: block;
}

// when the container is greater than 660px
@container (inline-size > 660px ) {
  .manager-card {
    display: flex;
  }
}
```

Just like media queries we tell the browser to apply specific styles when the container size is
less or greater than a certain value. In this case we changing from block to flex when the container
is greater than 660px.

### Container Condition

Another added advantage of using container queries is that we can use the much more comfortable syntax
for our size conditionals. The min and max width syntax will also work but I find this new syntax more
inline with the rest of our programming languages. Unlike media queries, container query rule set has
a much more dynamic condition set. Here are a few neat examples directly from
[mdn](https://developer.mozilla.org/en-US/docs/Web/CSS/@container), I would highly recommend the article
to look at all available options.

```css
@container (width > 400px) and (height > 400px) {
  /* <stylesheet> */
}

@container (width > 400px) or (height > 400px) {
  /* <stylesheet> */
}

@container not (width < 400px) {
  /* <stylesheet> */
}
```

### Container Name

By default, the container query will apply styles based on the nearest parent with containment context.
But there may be times when you would like to control the containment context that your container query
is based on. For this we can use the container-name property.

```css
/* A single name */
container-name: managerCardContainer;

/* Multiple names */
container-name: managerCardContainer managerCardParent;

/* Using the container name */
@container managerCardContainer (inline-size > 660px ) {
  .manager-card {
    display: flex;
  }
}
```

You can also shorthand to for setting container name and type:

```css
.manager-card-container {
  container: managerCardContainer / inline-size;
}
```

## Container Query Gotchas

</article>
