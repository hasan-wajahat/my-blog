import { MdxImage as Image } from '@/components/MdxImage';
import { getMetadataBySlug } from '../articleList';
import { ManagerCard } from './ManagerCard';
import heroImage from './hero.webp';
import inFlyoutImage from './in-flyout.webp';
import inMainPageImage from './in-main-page.webp';
import browserSupport from './browser-support.webp';

export const metadata = getMetadataBySlug('container-queries');

<Image
  src={heroImage}
  sizes="(max-width: 768px) 100vw, (max-width: 1200px) 50vw, 33vw"
  priority
  alt="Hero Image"
  aria-hidden
/>

<article>
# Container Queries

As the web has evolved, we have moved to using more and more components. Be it
frontend frameworks like React or Svelte, or templating languages like Laravel Blade;
all of them depend on the concept of components. These components can be used inside
dialogs, split-screens, or the main content area, meaning their size requirements can
vary widely. Luckily for us, CSS has caught up with this trend and has introduced a
new feature called Container Queries, which allows us to style components based on
their container size.

You may be wondering, ‚ÄúHasan, we already have media queries!‚Äù. And you are right, of
course, but media queries are based on the viewport size. Wouldn‚Äôt it be nice if your
component could be aware of its container size and adjust accordingly? And all that
without a single line of JS? Now that I have your attention (hopefully), let‚Äôs dive in.

## When to use Container Queries

Below I am rendering a simple ManagerCard component that we use in bunch of places in [Sematext](https://sematext.com/).
This is a simplified (and cruder) version of the original component.

<ManagerCard />
<figcaption>
  With MDX I can render the component instead of using an image.
</figcaption>

The component can be rendered in different places on our site as shown below:

<figure>
  <Image src={inMainPageImage} alt="ManagerCard in main page" />
  <figcaption>ManagerCard in main page</figcaption>
</figure>
<figure>
  <Image src={inFlyoutImage} alt="ManagerCard in flyout" />
  <figcaption>ManagerCard in flyout</figcaption>
</figure>

Before I introduced container queries, we had to pass additional props like ‚Äúminimal‚Äù to the
component to adjust its sizing depending on where it was rendered. And this could become overly
complex as we we continue to add it in different places. This becomes worse when you consider smaller
screens like tablets.

But with container queries it did not matter where this component is used. It will automatically adjust
its styling based on space available. This allows use to get rid of the additional props and makes the
component more reusable and easier to maintain.

## How to use Container Queries

Lets see how would use container queries to style the ManagerCard component.

```js
<div className="manager-card-container">
  <div className="manager-card">
    <h3>ManagerCard</h3>
    <p>Some content</p>
  </div>
</div>
```

To begin with we need to define a container and set the container-type property:

```css
.manager-card-container {
  container-type: inline-size;
  width: 100%;
}
```

The container-type property can have 3 possible values:

- size: Uses width and height of the container
- inline-size: Uses width of the container
- normal: The element is not a query container

We will explain in a little more detail the what these values mean but first lets see
how we use they query part of container queries.

```css
// default size
.manager-card {
  display: block;
}

// when the container is greater than 660px
@container (inline-size > 660px ) {
  .manager-card {
    display: flex;
  }
}
```

Just like media queries we tell the browser to apply specific styles when the container size is
less or greater than a certain value. In this case we changing from block to flex when the container
is greater than 660px.

### Container Condition

Another added advantage of using container queries is that we can use the much more comfortable syntax
for our size conditionals. The min and max width syntax will also work but I find this new syntax more
inline with the rest of our programming languages. Unlike media queries, container query rule set has
a much more dynamic condition set. Here are a few neat examples directly from
[mdn](https://developer.mozilla.org/en-US/docs/Web/CSS/@container), I would highly recommend the article
to look at all available options.

```css
@container (width > 400px) and (height > 400px) {
  /* <stylesheet> */
}

@container (width > 400px) or (height > 400px) {
  /* <stylesheet> */
}

@container not (width < 400px) {
  /* <stylesheet> */
}
```

### Container Name

By default, the container query will apply styles based on the nearest parent with containment context.
But there may be times when you would like to control the containment context that your container query
is based on. For this we can use the container-name property.

```css
/* A single name */
container-name: managerCardContainer;

/* Multiple names */
container-name: managerCardContainer managerCardParent;

/* Using the container name */
@container managerCardContainer (inline-size > 660px ) {
  .manager-card {
    display: flex;
  }
}
```

You can also shorthand to for setting container name and type:

```css
.manager-card-container {
  container: managerCardContainer / inline-size;
}
```

## Container Query Gotchas

Container queries turn off the ability of the element to get size information of the container
from its content. So as soon you define an element as a container it will collapse irrespective of
what content it has. Unless you specify the width and height of the container explicitly.

This is where we revisit the container type. As we saw we have 3 possible values for container type.
We don't care about the normal value as that is just the default for elements and means we don't have
any container query size calculations for the container. The other 2 properties allow us to access the
magic of container queries. When using ‚Äúcontainer-type: size‚Äù then the queries can check both width and
height of the element. This also means that we have to specify both width and height of the container.

In my experience ‚Äúcontainer-type: inline-size‚Äù is the most useful one. For one thing you only need
to specify the width of the container. And mostly for applying styles I find that width of the container
is more important than the height.

## Usage in TailwindCSS

If you are like me and love tailwind then you would be pleased to know that tailwind also supports
container queries. This support is not out of the box but there is an official plugin
[tailwindcss-container-queries](https://github.com/tailwindlabs/tailwindcss-container-queries) that
helps you write container queries today.

Here is how you would use it:

```html
<div class="@container">
  <div class="@lg:flex">
    <!-- Makes the div a flexbox when the container is larger than `32rem` -->
  </div>
</div>
```

## Browser Support

Well the good news does not end here! Container queries are not supported in all major browsers
and you can safely use it in production sites today.

<figure>
  <Image src={browserSupport} alt="Can I use container queries" />
  <figcaption>Browser Support for Container queries</figcaption>
</figure>

## Conclusion

Container queries is one of the best features that has been added to CSS in recent years. It
fits so well with the component architecture of the web today. It is not only easy to use but
has great browser support today! So go out and give it a go üöÄ.

</article>
